/***************************************************************************
 *   Copyright (C) 2010 by Daniel Calviño Sánchez <danxuliu@gmail.com>     *
 *   Copyright (C) 2011 by Daniel Calviño Sánchez <danxuliu@gmail.com>     *
 *   Copyright (C) 2012 by Daniel Calviño Sánchez <danxuliu@gmail.com>     *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; If not, see <http://www.gnu.org/licenses/>.  *
 ***************************************************************************/

#ifndef TUTORIALREADER_H
#define TUTORIALREADER_H

#include "DeserializationException.h"

class QDomElement;
class Reaction;
class Step;
class Tutorial;
class WaitFor;

/**
 * Deserializer for tutorials stored in XML.
 * Creates a new Tutorial from the XML data generated by TutorialWriter. Anyway,
 * if the XML data is not valid (see Tutorial.xsd for the W3C Schema), it
 * ignores unknown attributes and elements, and uses those known to create the
 * tutorial.
 *
 * @see TutorialWriter
 */
class TutorialReader {
public:

    /**
     * Creates a new TutorialReader.
     */
    TutorialReader();

    /**
     * Returns the Tutorial stored in the given XML serialization.
     * The tutorial must be deleted explicitly.
     *
     * If the XML is not well formed or its root element is not a "tutorial"
     * element, a DeserializationException is thrown. In any other case, even if
     * the XML is not valid, the deserializer tries to do its best: it ignores
     * unknown attributes and elements and deserializes all the attributes and
     * elements it knows.
     *
     * @param data The XML serialization.
     * @return The Tutorial stored in the given XML serialization.
     * @throw DeserializationException If there was a problem deserializing the
     *        tutorial.
     */
    Tutorial* readTutorial(const QString& data)
    throw (DeserializationException);

private:

    /**
     * Reads a new Tutorial from the "tutorial" XML element.
     *
     * @param element The element to read the Tutorial from.
     * @return The new Tutorial.
     */
    Tutorial* readTutorial(const QDomElement& element);

    /**
     * Reads a new Step from the "step" XML element.
     *
     * @param element The element to read the Step from.
     * @return The new Step.
     */
    Step* readStep(const QDomElement& element);

    /**
     * Reads a new Reaction from the "reaction" XML element.
     *
     * @param element The element to read the Reaction from.
     * @return The new Reaction.
     */
    Reaction* readReaction(const QDomElement& element);

    /**
     * Returns a new WaitFor object from the appropriate subclass.
     *
     * @param element The element to read the WaitFor from.
     * @return The new WaitFor.
     */
    WaitFor* readWaitFor(const QDomElement& element);

    /**
     * Reads a new WaitForComposed from the "waitForComposed" XML element.
     *
     * @param element The element to read the WaitForComposed from.
     * @return The new WaitForComposed.
     */
    WaitFor* readWaitForComposed(const QDomElement& element);

    /**
     * Reads a new WaitForEvent from the "waitForEvent" XML element.
     *
     * @param element The element to read the WaitForEvent from.
     * @return The new WaitForEvent.
     */
    WaitFor* readWaitForEvent(const QDomElement& element);

    /**
     * Reads a new WaitForNot from the "waitForNot" XML element.
     *
     * @param element The element to read the WaitForNot from.
     * @return The new WaitForNot.
     */
    WaitFor* readWaitForNot(const QDomElement& element);

    /**
     * Reads a new WaitForProperty from the "waitForProperty" XML element.
     *
     * @param element The element to read the WaitForProperty from.
     * @return The new WaitForProperty.
     */
    WaitFor* readWaitForProperty(const QDomElement& element);

    /**
     * Reads a new WaitForSignal from the "waitForSignal" XML element.
     *
     * @param element The element to read the WaitForSignal from.
     * @return The new WaitForSignal.
     */
    WaitFor* readWaitForSignal(const QDomElement& element);

    /**
     * Reads a new WaitForStepActivation from the "waitForStepActivation" XML
     * element.
     *
     * @param element The element to read the WaitForStepActivation from.
     * @return The new WaitForStepActivation.
     */
    WaitFor* readWaitForStepActivation(const QDomElement& element);

    /**
     * Reads a new WaitForWindow from the "waitForWindow" XML element.
     *
     * @param element The element to read the WaitForWindow from.
     * @return The new WaitForWindow.
     */
    WaitFor* readWaitForWindow(const QDomElement& element);

    /**
     * Returns whether the given element is one of the WaitFor elements or not.
     *
     * @param element The element to check.
     * @return Whether the given element is one of the WaitFor elements or not.
     */
    bool isWaitForElement(const QDomElement& element);

};

#endif
